import detectEthereumProvider from "@metamask/detect-provider";
import {
  Contract,
  providers as ethersProviders,
  utils as ethersUtils,
} from "ethers";

import Credential from "@models/Credential";
import {
  ERROR_PROVIDER_NOT_DETECTED,
  ERROR_PROVIDER_NOT_METAMASK,
  ERROR_PROVIDER_OVERRIDE,
  ERROR_PROVIDER_NOT_INITIALIZED,
} from "@services/EthereumProviderService/Errors";

import ContractsAddresses from "@contracts/addresses.json";
import ClaimsRegistry from "@contracts/ClaimsRegistry.json";

class EthereumProviderService {
  private static instance: EthereumProviderService;
  private web3Provider?: ethersProviders.Web3Provider;

  public static getInstance(): EthereumProviderService {
    if (!EthereumProviderService.instance) {
      EthereumProviderService.instance = new EthereumProviderService();
    }

    return EthereumProviderService.instance;
  }

  public async init(): Promise<ethersProviders.Web3Provider> {
    // detect the browser ethereum provider
    const provider = await detectEthereumProvider();

    if (!provider) {
      throw ERROR_PROVIDER_NOT_DETECTED();
    }

    if (provider !== window.ethereum) {
      throw ERROR_PROVIDER_OVERRIDE();
    }

    if (!window.ethereum?.isMetaMask) {
      throw ERROR_PROVIDER_NOT_METAMASK();
    }

    this.web3Provider = new ethersProviders.Web3Provider(window.ethereum);

    return this.web3Provider;
  }

  public isAvailable() {
    return this.web3Provider !== undefined;
  }

  private ensureProviderIsInitialized() {
    if (!this.isAvailable()) {
      throw ERROR_PROVIDER_NOT_INITIALIZED();
    }
  }

  public async getAccountAddress() {
    this.ensureProviderIsInitialized();

    const accounts = await this.web3Provider!.provider.request!({
      method: "eth_requestAccounts",
    });

    if (accounts.length === 0) {
      return;
    }

    return accounts[0];
  }

  public async credentialStore(address: string, serializedCredential: string) {
    try {
      // restore the credential
      const parsedCredential = Credential.parse(serializedCredential);
      const rootHashByteArray = ethersUtils.arrayify(parsedCredential.rootHash);

      // store credential
      const signer = this.web3Provider!.getSigner(address);

      const claimsRegistry = new Contract(
        ContractsAddresses.CLAIMS_REGISTRY,
        ClaimsRegistry.abi,
        signer,
      );

      // get the hash generated by the smart contract
      const signableHash = await claimsRegistry.computeSignableKey(
        parsedCredential.claimerAddress,
        rootHashByteArray,
      );

      // sign the signable hash with user's wallet
      const signature = await signer.signMessage(
        ethersUtils.arrayify(signableHash),
      );

      // store the credential on-chain
      const storingResult = await claimsRegistry.setClaimWithSignature(
        parsedCredential.claimerAddress,
        parsedCredential.attesterAddress,
        rootHashByteArray,
        signature,
      );

      // add transaction hash to the credential
      parsedCredential.transactionHash = storingResult.hash;

      return parsedCredential.serialize();
    } catch (error) {
      console.error(error);
      throw error;
    }
  }

  public async stake(address: string, amount: number) {
    // pre-approve stake for the address

    // stake amount

    return;
  }

  public async withdraw(address: string) {
    // withdraw from pool

    return;
  }
}

const ethereumProvider: EthereumProviderService = EthereumProviderService.getInstance();

export default ethereumProvider;
